# main.py ‚Äî Innertrade Kai Mentor Bot
# –í–µ—Ä—Å–∏—è: 2025-10-18 (coach-struct v9.0, "—Ç–æ–Ω–∫–∏–π –¥–∏—Ä–∏–∂—ë—Ä")
# –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏:
#  - –í–µ–¥—É—â–∞—è —Ä–æ–ª—å —É ChatGPT: –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞, –∂–∏–≤–æ–π –¥–∏–∞–ª–æ–≥, –≥–ª—É–±–∏–Ω–∞.
#  - –û—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä (–∫–æ–¥) —Å–ª–µ–¥–∏—Ç –∑–∞ UX: –æ–¥–∏–Ω —Ö–æ–¥ = –æ–¥–∏–Ω –≤–æ–ø—Ä–æ—Å/–¥–µ–π—Å—Ç–≤–∏–µ;
#    –Ω–∏–∫–∞–∫–æ–≥–æ "–¥–≤–æ–π–Ω–æ–≥–æ" —Å–æ–æ–±—â–µ–Ω–∏—è (–≤–æ–ø—Ä–æ—Å + –∫–Ω–æ–ø–∫–∏ + —Ä–µ–∑—é–º–µ –≤ –æ–¥–Ω–æ–º).
#  - –¢–µ—Ö–Ω–∏–∫–∞ (MERCEDES/TOTE) —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã
#    –∏–ª–∏ —è–≤–Ω—ã—Ö —Ä–∏—Å–∫-–ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤, –∏ —Ç–æ–ª—å–∫–æ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Ö–æ–¥–æ–º.
#  - –ù–ï–¢ –∂—ë—Å—Ç–∫–æ–≥–æ —Å—á—ë—Ç—á–∏–∫–∞ "–ø–æ—Å–ª–µ 3-–≥–æ —à–∞–≥–∞" ‚Äî –º–æ–¥–µ–ª—å —Å–∞–º–∞ –≤–µ–¥—ë—Ç,
#    –∫–æ–¥ –ª–∏—à—å —Å—Ç—Ä–∞—Ö—É–µ—Ç –æ—Ç —Å–ª–∏—à–∫–æ–º —Ä–∞–Ω–Ω–µ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞.
#  - –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: Flask 3.x, TeleBot, SQLAlchemy 2.x, psycopg3, OpenAI 1.108.x

import os
import json
import time
import threading
import logging
import hashlib
import re
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, Optional, List

import requests
from flask import Flask, request, abort, jsonify
from sqlalchemy import create_engine, text
from sqlalchemy.pool import QueuePool
import telebot
from telebot import types
from openai import OpenAI

# ========= Version / Hash =========
def _code_hash() -> str:
    try:
        with open(__file__, "rb") as f:
            return hashlib.md5(f.read()).hexdigest()[:8]
    except Exception:
        return "unknown"

BOT_VERSION = f"2025-10-18-{_code_hash()}"

# ========= ENV =========
def _env(name: str, default: str = "") -> str:
    return os.getenv(name, default).strip()

TELEGRAM_TOKEN = _env("TELEGRAM_TOKEN")
PUBLIC_URL     = _env("PUBLIC_URL")
WEBHOOK_PATH   = _env("WEBHOOK_PATH", "webhook")
TG_SECRET      = _env("TG_WEBHOOK_SECRET")
DATABASE_URL   = _env("DATABASE_URL")
OPENAI_API_KEY = _env("OPENAI_API_KEY")
OPENAI_MODEL   = _env("OPENAI_MODEL", "gpt-4o-mini")

OFFSCRIPT_ENABLED = _env("OFFSCRIPT_ENABLED", "true").lower() == "true"
SET_WEBHOOK_FLAG  = _env("SET_WEBHOOK", "true").lower() == "true"
LOG_LEVEL         = _env("LOG_LEVEL", "INFO").upper()
MAX_BODY          = int(_env("MAX_BODY", "1000000"))

# –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ idle
REMINDERS_ENABLED   = _env("REMINDERS_ENABLED", "true").lower() == "true"
IDLE_MINUTES_REMIND = int(_env("IDLE_MINUTES_REMIND", "60"))
IDLE_MINUTES_RESET  = int(_env("IDLE_MINUTES_RESET", "240"))

# –•—Ä–∞–Ω–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Ä–µ–ø–ª–∏–∫ (–∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç)
HIST_LIMIT = 18

# ========= Guards =========
_missing = [k for k in
            ["TELEGRAM_TOKEN", "PUBLIC_URL", "WEBHOOK_PATH", "TG_WEBHOOK_SECRET", "DATABASE_URL", "OPENAI_API_KEY"]
            if not globals()[k]]
if _missing:
    raise RuntimeError(f"ENV variables missing: {', '.join(_missing)}")

# ========= Logging =========
logging.basicConfig(level=LOG_LEVEL, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")
log = logging.getLogger("kai-mentor")
log.info(f"Starting bot version: {BOT_VERSION}")

# ========= Intents/Steps =========
INTENT_GREET = "greet"
INTENT_FREE  = "free"       # –∫–æ—É—á-—Å–ª–æ–π, –∂–∏–≤–æ–π –¥–∏–∞–ª–æ–≥
INTENT_ERR   = "error"      # —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–π —Ä–∞–∑–±–æ—Ä
INTENT_DONE  = "done"

STEP_ASK_STYLE  = "ask_style"
STEP_FREE_CHAT  = "free_chat"       # –∂–∏–≤–∞—è –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞
STEP_ERR_DESCR  = "err_describe"    # ¬´–æ–ø–∏—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫–µ–π—Å¬ª
STEP_MER_CTX    = "mer_context"
STEP_MER_EMO    = "mer_emotions"
STEP_MER_THO    = "mer_thoughts"
STEP_MER_BEH    = "mer_behavior"
STEP_GOAL       = "goal_positive"
STEP_TOTE_OPS   = "tote_ops"
STEP_TOTE_TEST  = "tote_test"
STEP_TOTE_EXIT  = "tote_exit"

MER_ORDER = [STEP_MER_CTX, STEP_MER_EMO, STEP_MER_THO, STEP_MER_BEH]

# ========= Risk/Emotion patterns (–¥–ª—è —Å—Ç—Ä–∞—Ö–æ–≤–∫–∏ —Ä–∞–Ω–Ω–µ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞) =========
RISK_PATTERNS = {
    "remove_stop": ["—É–±–∏—Ä–∞—é —Å—Ç–æ–ø", "—Å–Ω—è–ª —Å—Ç–æ–ø", "–±–µ–∑ —Å—Ç–æ–ø–∞"],
    "move_stop": ["–¥–≤–∏–≥–∞—é —Å—Ç–æ–ø", "–æ—Ç–æ–¥–≤–∏–Ω—É–ª —Å—Ç–æ–ø", "–ø–µ—Ä–µ—Å—Ç–∞–≤–∏–ª —Å—Ç–æ–ø"],
    "early_close": ["–∑–∞–∫—Ä—ã–ª —Ä–∞–Ω–æ", "–≤—ã—à–µ–ª –≤ –Ω–æ–ª—å", "–º–∏–∑–µ—Ä–Ω—ã–π –ø–ª—é—Å", "—Ä–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥"],
    "averaging": ["—É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ", "–¥–æ–ª–∏–≤–∞–ª—Å—è –ø—Ä–æ—Ç–∏–≤", "–¥–æ–∫—É–ø–∞–ª –ø—Ä–æ—Ç–∏–≤"],
    "fomo": ["–ø–æ–µ–∑–¥ —É–µ–¥–µ—Ç", "—É–ø—É—Å—Ç–∏–ª", "—É–π–¥—ë—Ç –±–µ–∑ –º–µ–Ω—è", "—Å—Ç—Ä–∞—Ö —É–ø—É—Å—Ç–∏—Ç—å"],
    "rule_breaking": ["–Ω–∞—Ä—É—à–∏–ª –ø–ª–∞–Ω", "–æ—Ç–æ—à—ë–ª –æ—Ç –ø–ª–∞–Ω–∞", "–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–ª –ø–ª–∞–Ω"],
}
EMO_PATTERNS = {
    "self_doubt": ["—Å–æ–º–Ω–µ–≤–∞—é—Å—å", "–Ω–µ —É–≤–µ—Ä–µ–Ω", "—Å—Ç—Ä–µ—Å—Å", "–ø–∞–Ω–∏–∫–∞", "–≤–æ–ª–Ω–µ–Ω–∏–µ"],
    "fear_of_loss": ["—Å—Ç—Ä–∞—Ö –ø–æ—Ç–µ—Ä—å", "–±–æ—é—Å—å —Å—Ç–æ–ø–∞", "–Ω–µ —Ö–æ—á—É –±—ã—Ç—å –æ–±–º–∞–Ω—É—Ç—ã–º"],
}

def detect_patterns(text_in: str) -> List[str]:
    tl = (text_in or "").lower()
    hits = []
    for name, keys in {**RISK_PATTERNS, **EMO_PATTERNS}.items():
        if any(k in tl for k in keys):
            hits.append(name)
    return hits

def risky(text_in: str) -> bool:
    pats = set(detect_patterns(text_in))
    return bool(pats & set(RISK_PATTERNS.keys())) or ("fear_of_loss" in pats) or ("self_doubt" in pats)

# ========= OpenAI =========
oai_client: Optional[OpenAI] = None
openai_status = "disabled"
if OPENAI_API_KEY and OFFSCRIPT_ENABLED:
    try:
        oai_client = OpenAI(api_key=OPENAI_API_KEY)
        # –õ—ë–≥–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        oai_client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[{"role": "user", "content": "ping"}],
            max_tokens=4,
        )
        openai_status = "active"
        log.info("OpenAI ready")
    except Exception as e:
        log.error(f"OpenAI init error: {e}")
        openai_status = f"error: {e}"
        oai_client = None

# ========= DB =========
engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=5,
    max_overflow=10,
    pool_timeout=30,
    pool_recycle=1800,
)

def db_exec(sql: str, params: Optional[Dict[str, Any]] = None):
    with engine.begin() as conn:
        return conn.execute(text(sql), params or {})

def init_db():
    db_exec("""
    CREATE TABLE IF NOT EXISTS user_state(
        user_id BIGINT PRIMARY KEY,
        intent TEXT,
        step TEXT,
        data TEXT,
        updated_at TIMESTAMPTZ DEFAULT now()
    );
    """)
    db_exec("CREATE INDEX IF NOT EXISTS idx_user_state_updated_at ON user_state(updated_at)")
    db_exec("CREATE INDEX IF NOT EXISTS idx_user_state_intent_step ON user_state(intent, step)")
    log.info("DB initialized")

# ========= State helpers =========
def _now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def load_state(uid: int) -> Dict[str, Any]:
    row = db_exec("SELECT intent, step, data FROM user_state WHERE user_id=:uid", {"uid": uid}).mappings().first()
    if row:
        data = {}
        if row["data"]:
            try:
                data = json.loads(row["data"])
            except Exception as e:
                log.error("parse user data error: %s", e)
                data = {}
        data.setdefault("history", [])
        return {"user_id": uid, "intent": row["intent"] or INTENT_GREET, "step": row["step"] or STEP_ASK_STYLE, "data": data}
    return {"user_id": uid, "intent": INTENT_GREET, "step": STEP_ASK_STYLE, "data": {"history": []}}

def save_state(uid: int, intent: Optional[str] = None, step: Optional[str] = None, data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    cur = load_state(uid)
    intent = intent or cur["intent"]
    step   = step   or cur["step"]
    new_data = cur["data"].copy()
    if data:
        new_data.update(data)
    new_data["last_state_write_at"] = _now_iso()
    db_exec("""
        INSERT INTO user_state (user_id, intent, step, data, updated_at)
        VALUES (:uid, :intent, :step, :data, now())
        ON CONFLICT (user_id) DO UPDATE
        SET intent=EXCLUDED.intent, step=EXCLUDED.step, data=EXCLUDED.data, updated_at=now()
    """, {"uid": uid, "intent": intent, "step": step, "data": json.dumps(new_data, ensure_ascii=False)})
    return {"user_id": uid, "intent": intent, "step": step, "data": new_data}

def _append_history(data: Dict[str, Any], role: str, content: str) -> Dict[str, Any]:
    hist = data.get("history", [])
    if len(hist) >= HIST_LIMIT:
        hist = hist[-(HIST_LIMIT - 1):]
    hist.append({"role": role, "content": content})
    data["history"] = hist
    return data

# ========= Flask/TeleBot =========
bot = telebot.TeleBot(TELEGRAM_TOKEN, parse_mode="HTML", threaded=False)
app = Flask(__name__)

MAIN_MENU = types.ReplyKeyboardMarkup(resize_keyboard=True)
MAIN_MENU.row("üöë –£ –º–µ–Ω—è –æ—à–∏–±–∫–∞", "üß© –•–æ—á—É —Å—Ç—Ä–∞—Ç–µ–≥–∏—é")
MAIN_MENU.row("üìÑ –ü–∞—Å–ø–æ—Ä—Ç", "üóí –ü–∞–Ω–µ–ª—å –Ω–µ–¥–µ–ª–∏")
MAIN_MENU.row("üÜò –≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ", "ü§î –ù–µ –∑–Ω–∞—é, —Å —á–µ–≥–æ –Ω–∞—á–∞—Ç—å")

STYLE_KB = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
STYLE_KB.row("—Ç—ã", "–≤—ã")

# ========= GPT: –∫–æ—É—á-—Å–ª–æ–π (–µ–¥–∏–Ω—ã–π –≤–æ–ø—Ä–æ—Å –∑–∞ —Ö–æ–¥) =========
def gpt_calibrate(uid: int, text_in: str, st: Dict[str, Any]) -> Dict[str, Any]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç JSON:
      response_text: –∫–æ—Ä–æ—Ç–∫–∏–π, —á–µ–ª–æ–≤–µ—á–Ω—ã–π, 1 –≤–æ–ø—Ä–æ—Å, –±–µ–∑ —Å–æ–≤–µ—Ç–æ–≤
      store: dict (—á—Ç–æ –ø–æ–ª–æ–∂–∏—Ç—å –≤ –ø–∞–º—è—Ç—å)
      summary_draft: –∫–æ—Ä–æ—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ –ø—Ä–æ–±–ª–µ–º—ã –ò–õ–ò ""
      readiness_score: float 0..1 (–≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ)
      ask_confirm: bool (–ø–æ–ø—Ä–æ—Å–∏—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–µ–∑—é–º–µ)
    """
    fallback = {
        "response_text": "–û–∫–µ–π. –ß—Ç–æ–±—ã –Ω–µ —Å–ø–µ—à–∏—Ç—å, —Å–∫–∞–∂–∏ –∫–æ—Ä–æ—Ç–∫–æ: –≥–¥–µ –∏–º–µ–Ω–Ω–æ –Ω–∞—á–∏–Ω–∞–µ—Ç —É–≤–æ–¥–∏—Ç—å –æ—Ç –ø–ª–∞–Ω–∞ ‚Äî –≤—Ö–æ–¥, —Å—Ç–æ–ø –∏–ª–∏ –≤—ã—Ö–æ–¥?",
        "store": {},
        "summary_draft": "",
        "readiness_score": 0.0,
        "ask_confirm": False,
    }
    if not oai_client or not OFFSCRIPT_ENABLED:
        return fallback

    style = st["data"].get("style", "—Ç—ã")
    history = st["data"].get("history", [])

    system = f"""
–¢—ã ‚Äî –ê–ª–µ–∫—Å, –∫–æ—É—á-–Ω–∞—Å—Ç–∞–≤–Ω–∏–∫. –ì–æ–≤–æ—Ä–∏—à—å –Ω–∞ ¬´{style}¬ª, –ø—Ä–æ—Å—Ç–æ –∏ –ø–æ-—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏.
–ó–∞–¥–∞—á–∞: —É–≥–ª—É–±–ª—è—Ç—å—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç –∫–æ—Ä–æ—Ç–∫–∏–º–∏ –≤–æ–ø—Ä–æ—Å–∞–º–∏ (–û–î–ò–ù –≤–æ–ø—Ä–æ—Å –∑–∞ —Ö–æ–¥), –∞–∫–∫—É—Ä–∞—Ç–Ω–æ
–ø–æ–¥–≤–æ–¥–∏—Ç—å –∫ —á—ë—Ç–∫–æ–º—É —Ä–µ–∑—é–º–µ –ø—Ä–æ–±–ª–µ–º—ã. –ù–∏–∫–∞–∫–∏—Ö —Å–æ–≤–µ—Ç–æ–≤ –∏ —Å–ø–∏—Å–∫–æ–≤ —Ç–µ—Ö–Ω–∏–∫ –Ω–∞ —ç—Ç–∞–ø–µ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏.
–¢–µ—Ö–Ω–∏–∫–∏ (–∏ –≤–æ–æ–±—â–µ —Å–ª–æ–≤–æ "—Ç–µ—Ö–Ω–∏–∫–∞") –Ω–µ —É–ø–æ–º–∏–Ω–∞–π. –°–Ω–∞—á–∞–ª–∞: –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞ ‚Üí —Ä–µ–∑—é–º–µ ‚Üí –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.
–ö–æ–≥–¥–∞ —É–≤–µ—Ä–µ–Ω, —á—Ç–æ —á–µ–ª–æ–≤–µ–∫ —á–µ—Ç–∫–æ –Ω–∞–∑–≤–∞–ª –ø—Ä–æ–±–ª–µ–º—É ‚Äî readiness_score –±–ª–∏–∂–µ –∫ 1.0.
–ï—Å–ª–∏ —É–∂–µ –º–æ–∂–Ω–æ ‚Äî –¥–∞–π –∫—Ä–∞—Ç–∫–æ–µ summary_draft (1‚Äì2 —Å—Ç—Ä–æ–∫–∏) –∏ ask_confirm=true.
–û—Ç–≤–µ—Ç ‚Äî —Å—Ç—Ä–æ–≥–æ JSON: response_text, store, summary_draft, readiness_score, ask_confirm.
""".strip()

    msgs = [{"role": "system", "content": system}]
    for h in history[-HIST_LIMIT:]:
        if h.get("role") in ("user", "assistant"):
            msgs.append(h)
    msgs.append({"role": "user", "content": text_in})

    try:
        res = oai_client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=msgs,
            temperature=0.3,
            response_format={"type":"json_object"},
        )
        raw = res.choices[0].message.content or "{}"
        js = json.loads(raw)
        # sanity
        for k in ["response_text","store","summary_draft","readiness_score","ask_confirm"]:
            if k not in js:
                return fallback
        # safety: —Ä–æ–≤–Ω–æ –æ–¥–∏–Ω –≤–æ–ø—Ä–æ—Å (–Ω–µ –±–æ–ª–µ–µ 1 '?')
        rt = (js.get("response_text") or "").strip()
        if rt.count("?") > 1:
            # –æ—Å—Ç–∞–≤–∏–º –ø–µ—Ä–≤—É—é –≤–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω—É—é —á–∞—Å—Ç—å
            first = rt.split("?")[0].strip()
            rt = first + "?"
        if len(rt) < 6:
            rt = fallback["response_text"]
        js["response_text"] = rt[:900]  # –∫–æ—Ä–æ—Ç–∫–æ
        # –∫–∞–ª–∏–±—Ä–æ–≤–æ—á–Ω—ã–π "store"
        if not isinstance(js.get("store"), dict):
            js["store"] = {}
        # readiness –≤ 0..1
        try:
            r = float(js.get("readiness_score", 0))
            js["readiness_score"] = max(0.0, min(1.0, r))
        except Exception:
            js["readiness_score"] = 0.0
        return js
    except Exception as e:
        log.error("gpt_calibrate error: %s", e)
        return fallback

def extract_summary_from_memory(data: Dict[str, Any]) -> str:
    # –ù–µ–±–æ–ª—å—à–æ–π –∞–≤—Ç–æ-—Ä–µ–∑—é–º –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –º–æ–¥–µ–ª—å –Ω–∏—á–µ–≥–æ –Ω–µ –¥–∞–ª–∞
    user_msgs = [m["content"] for m in data.get("history", []) if m.get("role") == "user"]
    pats = []
    for m in user_msgs:
        pats.extend(detect_patterns(m))
    parts = []
    s = set(pats)
    if "fomo" in s: parts.append("FOMO / —Å—Ç—Ä–∞—Ö —É–ø—É—Å—Ç–∏—Ç—å")
    if "remove_stop" in s or "move_stop" in s: parts.append("—Ç—Ä–æ–≥–∞–µ—à—å/—Å–Ω–∏–º–∞–µ—à—å —Å—Ç–æ–ø")
    if "early_close" in s: parts.append("—Ä–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥")
    if "averaging" in s: parts.append("—É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ç–∏–≤ –ø–æ–∑–∏—Ü–∏–∏")
    if "fear_of_loss" in s: parts.append("—Å—Ç—Ä–∞—Ö –ø–æ—Ç–µ—Ä—å/—Å—Ç–æ–ø–∞")
    if "self_doubt" in s: parts.append("—Å–æ–º–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ –≤—Ö–æ–¥–∞")
    if not parts:
        return ""
    return "–ü–æ—Ö–æ–∂–µ –Ω–∞: " + ", ".join(parts)

# ========= Structural prompts =========
def mer_prompt_for(step: str) -> str:
    return {
        STEP_MER_CTX: "–ó–∞—Ñ–∏–∫—Å–∏—Ä—É–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É. –ì–¥–µ –∏ –∫–æ–≥–¥–∞ —ç—Ç–æ –±—ã–ª–æ? –ö–æ—Ä–æ—Ç–∫–æ.",
        STEP_MER_EMO: "–ß—Ç–æ –ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª –≤ –º–æ–º–µ–Ω—Ç–µ (2‚Äì3 —Å–ª–æ–≤–∞)?",
        STEP_MER_THO: "–ö–∞–∫–∏–µ –º—ã—Å–ª–∏ –º–µ–ª—å–∫–∞–ª–∏ (2‚Äì3 –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑—ã)?",
        STEP_MER_BEH: "–ß—Ç–æ —Å–¥–µ–ª–∞–ª —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏? –î–µ–π—Å—Ç–≤–∏—è.",
    }.get(step, "–ü—Ä–æ–¥–æ–ª–∂–∏–º.")

# ========= Handlers =========
@bot.message_handler(commands=["start", "reset"])
def cmd_start(m: types.Message):
    uid = m.from_user.id
    st = load_state(uid)
    # –ù–∞—á–∏–Ω–∞–µ–º —Å–≤–µ–∂–æ
    st = save_state(uid, INTENT_GREET, STEP_ASK_STYLE, {"history": []})
    bot.send_message(uid,
        "üëã –ü—Ä–∏–≤–µ—Ç! –ö–∞–∫ —É–¥–æ–±–Ω–µ–µ ‚Äî <b>—Ç—ã</b> –∏–ª–∏ <b>–≤—ã</b>?\n\n–ï—Å–ª–∏ –∑–∞—Ö–æ—á–µ—à—å –Ω–∞—á–∞—Ç—å —Å —á–∏—Å—Ç–æ–≥–æ –ª–∏—Å—Ç–∞ ‚Äî –Ω–∞–ø–∏—à–∏: <b>–Ω–æ–≤—ã–π —Ä–∞–∑–±–æ—Ä</b>.",
        reply_markup=STYLE_KB
    )

@bot.message_handler(commands=["version","v"])
def cmd_version(m: types.Message):
    bot.reply_to(m, (
        f"üîÑ –í–µ—Ä—Å–∏—è –±–æ—Ç–∞: {BOT_VERSION}\n"
        f"üìù –•—ç—à –∫–æ–¥–∞: {_code_hash()}\n"
        f"üïí –í—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä–∞: {datetime.now(timezone.utc).isoformat()}\n"
        f"ü§ñ OpenAI: {openai_status}"
    ))

@bot.message_handler(commands=["menu"])
def cmd_menu(m: types.Message):
    bot.send_message(m.chat.id, "–ú–µ–Ω—é:", reply_markup=MAIN_MENU)

@bot.message_handler(content_types=["text"])
def on_text(m: types.Message):
    uid = m.from_user.id
    text_in = (m.text or "").strip()
    handle_text(uid, text_in, m)

def handle_text(uid: int, text_in: str, original_message: Optional[types.Message] = None):
    st = load_state(uid)
    log.info("User %s: intent=%s step=%s text='%s'", uid, st["intent"], st["step"], text_in[:200])

    # –±—ã—Å—Ç—Ä—ã–π reset
    if text_in.lower() in ("–Ω–æ–≤—ã–π —Ä–∞–∑–±–æ—Ä","–Ω–æ–≤—ã–π","—Å —á–∏—Å—Ç–æ–≥–æ –ª–∏—Å—Ç–∞","start over"):
        st = save_state(uid, INTENT_FREE, STEP_FREE_CHAT, {"history": [], "coach_turns": 0, "struct_offer_shown": False})
        bot.send_message(uid, "–û–∫–µ–π, —á–∏—Å—Ç—ã–π –ª–∏—Å—Ç. –ß—Ç–æ —Å–µ–π—á–∞—Å —Ö–æ—á–µ—Ç—Å—è –ø–æ–ø—Ä–∞–≤–∏—Ç—å –≤ —Ç—Ä–µ–π–¥–∏–Ω–≥–µ?", reply_markup=MAIN_MENU)
        return

    # –∏—Å—Ç–æ—Ä–∏—è (user)
    st["data"] = _append_history(st["data"], "user", text_in)
    st["data"]["last_user_msg_at"] = _now_iso()
    st["data"]["awaiting_reply"] = True

    # –≤—ã–±–æ—Ä —Å—Ç–∏–ª—è
    if st["intent"] == INTENT_GREET and st["step"] == STEP_ASK_STYLE:
        if text_in.lower() in ("—Ç—ã","–≤—ã"):
            st["data"]["style"] = text_in.lower()
            st = save_state(uid, INTENT_FREE, STEP_FREE_CHAT, st["data"])
            bot.send_message(uid, f"–ü—Ä–∏–Ω—è—Ç–æ ({text_in}). –ù–∞—á–Ω—ë–º —Å–ø–æ–∫–æ–π–Ω–æ –∏ –±–µ–∑ —Å–ø–µ—à–∫–∏. –ß—Ç–æ —Å–µ–π—á–∞—Å –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ –º–µ—à–∞–µ—Ç?", reply_markup=MAIN_MENU)
        else:
            save_state(uid, data=st["data"])
            bot.send_message(uid, "–í—ã–±–µ—Ä–∏ ¬´—Ç—ã¬ª –∏–ª–∏ ¬´–≤—ã¬ª.", reply_markup=STYLE_KB)
        return

    # –ï—Å–ª–∏ —É–∂–µ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–º –ø–æ—Ç–æ–∫–µ ‚Äî –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –µ–≥–æ
    if st["intent"] == INTENT_ERR:
        proceed_struct(uid, text_in, st)
        return

    # ===== –ñ–∏–≤–æ–π –∫–æ—É—á-—Å–ª–æ–π (–≤–µ–¥—ë—Ç ChatGPT) =====
    turns = int(st["data"].get("coach_turns", 0))
    decision = gpt_calibrate(uid, text_in, st)
    resp = decision["response_text"]
    # –æ–±–Ω–æ–≤–∏–º –ø–∞–º—è—Ç—å
    mem = st["data"]
    mem = _append_history(mem, "assistant", resp)
    if decision.get("store"):
        try:
            mem.update(decision["store"])
        except Exception:
            pass
    if decision.get("summary_draft"):
        mem["problem_draft"] = decision["summary_draft"]

    readiness = float(decision.get("readiness_score", 0.0))
    turns += 1
    mem["coach_turns"] = turns
    st = save_state(uid, INTENT_FREE, STEP_FREE_CHAT, mem)

    # –û—Ç–≤–µ—á–∞–µ–º (–æ–¥–∏–Ω —Ö–æ–¥ = –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ)
    if original_message:
        bot.reply_to(original_message, resp, reply_markup=MAIN_MENU)
    else:
        bot.send_message(uid, resp, reply_markup=MAIN_MENU)

    # –ï—Å–ª–∏ –º–æ–¥–µ–ª—å –ø—Ä–æ—Å–∏—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ ‚Äî –≤—ã–Ω–æ—Å–∏–º –≠–¢–û –æ—Ç–¥–µ–ª—å–Ω—ã–º —Ö–æ–¥–æ–º
    if decision.get("ask_confirm") and mem.get("problem_draft"):
        kb = types.InlineKeyboardMarkup().row(
            types.InlineKeyboardButton("–î–∞, –≤–µ—Ä–Ω–æ", callback_data="confirm_problem"),
            types.InlineKeyboardButton("–ß—É—Ç—å –∏–Ω–∞—á–µ", callback_data="refine_problem")
        )
        bot.send_message(uid, f"–°—É–º–º–∏—Ä—É—é –∫–æ—Ä–æ—Ç–∫–æ:\n\n<b>{mem['problem_draft']}</b>\n\n–ü–æ–¥—Ö–æ–¥–∏—Ç?", reply_markup=kb)
        return

    # –ï—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª —Ä–∞–Ω—å—à–µ ‚Äî –º–æ–∂–Ω–æ –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É
    if mem.get("problem_confirmed"):
        offer_structure(uid, st)
        return

    # –°—Ç—Ä–∞—Ö–æ–≤–∫–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º —Ä–∞–Ω–Ω–µ–≥–æ —Å—Ç–∞—Ä—Ç–∞: –Ω—É–∂–Ω–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –ò –∫–æ–Ω—Ç–µ–∫—Å—Ç
    if readiness >= 0.85 and (turns >= 3 or risky(text_in)):
        # –ü–æ–ø—Ä–æ—Å–∏–º –∫–æ—Ä–æ—Ç–∫–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–µ–∑—é–º–µ (–µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç ‚Äî —Å–≥–µ–Ω–µ—Ä–∏–º –∏–∑ –ø–∞–º—è—Ç–∏)
        if not mem.get("problem_draft"):
            auto = extract_summary_from_memory(mem)
            if auto:
                mem["problem_draft"] = auto
                save_state(uid, data=mem)
        if mem.get("problem_draft"):
            kb = types.InlineKeyboardMarkup().row(
                types.InlineKeyboardButton("–î–∞, –≤–µ—Ä–Ω–æ", callback_data="confirm_problem"),
                types.InlineKeyboardButton("–ß—É—Ç—å –∏–Ω–∞—á–µ", callback_data="refine_problem")
            )
            bot.send_message(uid, f"–°—É–º–º–∏—Ä—É—é:\n\n<b>{mem['problem_draft']}</b>\n\n–ü–æ–¥—Ö–æ–¥–∏—Ç?", reply_markup=kb)

# ========= –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã (–æ—Ç–¥–µ–ª—å–Ω—ã–º —Ö–æ–¥–æ–º) =========
def offer_structure(uid: int, st: Dict[str, Any]):
    data = st["data"]
    if data.get("struct_offer_shown"):
        return
    data["struct_offer_shown"] = True
    save_state(uid, data=data)
    kb = types.InlineKeyboardMarkup().row(
        types.InlineKeyboardButton("–†–∞–∑–æ–±—Ä–∞—Ç—å –ø–æ —à–∞–≥–∞–º", callback_data="start_error_flow"),
        types.InlineKeyboardButton("–ü–æ–∫–∞ –Ω–µ—Ç", callback_data="skip_error_flow")
    )
    bot.send_message(uid, "–ì–æ—Ç–æ–≤ —Ä–∞–∑–æ–±—Ä–∞—Ç—å —ç—Ç–æ –ø–æ —à–∞–≥–∞–º (–∫–æ—Ä–æ—Ç–∫–æ –∏ –±–µ–∑ —Å–ø–µ—à–∫–∏)?", reply_markup=kb)

# ========= –°—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–π –ø–æ—Ç–æ–∫ =========
def proceed_struct(uid: int, text_in: str, st: Dict[str, Any]):
    step = st["step"]
    data = st["data"].copy()

    if step == STEP_ERR_DESCR:
        data["error_description"] = text_in
        save_state(uid, INTENT_ERR, STEP_MER_CTX, data)
        bot.send_message(uid, mer_prompt_for(STEP_MER_CTX), reply_markup=MAIN_MENU)
        return

    if step in MER_ORDER:
        mer = data.get("mer", {})
        mer[step] = text_in
        data["mer"] = mer
        idx = MER_ORDER.index(step)
        if idx + 1 < len(MER_ORDER):
            nxt = MER_ORDER[idx + 1]
            save_state(uid, INTENT_ERR, nxt, data)
            bot.send_message(uid, mer_prompt_for(nxt), reply_markup=MAIN_MENU)
        else:
            save_state(uid, INTENT_ERR, STEP_GOAL, data)
            bot.send_message(uid, "–°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –ø–æ–∑–∏—Ç–∏–≤–Ω—É—é —Ü–µ–ª—å: —á—Ç–æ –±—É–¥–µ—à—å –¥–µ–ª–∞—Ç—å –≤–º–µ—Å—Ç–æ –ø—Ä–µ–∂–Ω–µ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è?", reply_markup=MAIN_MENU)
        return

    if step == STEP_GOAL:
        data["goal"] = text_in
        save_state(uid, INTENT_ERR, STEP_TOTE_OPS, data)
        bot.send_message(uid, "–î–ª—è –±–ª–∏–∂–∞–π—à–∏—Ö 3 —Å–¥–µ–ª–æ–∫ –Ω–∞–∑–æ–≤–∏ 2‚Äì3 –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —à–∞–≥–∞ (–∫–æ—Ä–æ—Ç–∫–æ, —Å–ø–∏—Å–∫–æ–º).", reply_markup=MAIN_MENU)
        return

    if step == STEP_TOTE_OPS:
        tote = data.get("tote", {})
        tote["ops"] = text_in
        data["tote"] = tote
        save_state(uid, INTENT_ERR, STEP_TOTE_TEST, data)
        bot.send_message(uid, "–ö–∞–∫ –ø–æ–π–º—ë—à—å, —á—Ç–æ –ø–æ–ª—É—á–∏–ª–æ—Å—å? –û–¥–∏–Ω –ø—Ä–æ—Å—Ç–æ–π –∫—Ä–∏—Ç–µ—Ä–∏–π.", reply_markup=MAIN_MENU)
        return

    if step == STEP_TOTE_TEST:
        tote = data.get("tote", {})
        tote["test"] = text_in
        data["tote"] = tote
        save_state(uid, INTENT_ERR, STEP_TOTE_EXIT, data)
        bot.send_message(uid, "–ï—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–∫–∞–∂–µ—Ç ¬´–Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å¬ª ‚Äî —á—Ç–æ —Å–¥–µ–ª–∞–µ—à—å?", reply_markup=MAIN_MENU)
        return

    if step == STEP_TOTE_EXIT:
        tote = data.get("tote", {})
        tote["exit"] = text_in
        data["tote"] = tote

        mer = data.get("mer", {})
        summary = [
            "<b>–ò—Ç–æ–≥ —Ä–∞–∑–±–æ—Ä–∞</b>",
            f"–ü—Ä–æ–±–ª–µ–º–∞: {data.get('error_description', data.get('problem', '‚Äî'))}",
            f"–ö–æ–Ω—Ç–µ–∫—Å—Ç: {mer.get(STEP_MER_CTX, '‚Äî')}",
            f"–≠–º–æ—Ü–∏–∏: {mer.get(STEP_MER_EMO, '‚Äî')}",
            f"–ú—ã—Å–ª–∏: {mer.get(STEP_MER_THO, '‚Äî')}",
            f"–ü–æ–≤–µ–¥–µ–Ω–∏–µ: {mer.get(STEP_MER_BEH, '‚Äî')}",
            f"–¶–µ–ª—å: {data.get('goal', '‚Äî')}",
            f"–®–∞–≥–∏ (3 —Å–¥–µ–ª–∫–∏): {data.get('tote', {}).get('ops', '‚Äî')}",
            f"–ü—Ä–æ–≤–µ—Ä–∫–∞: {data.get('tote', {}).get('test', '‚Äî')}",
            f"–ï—Å–ª–∏ –Ω–µ –≤—ã—à–ª–æ: {data.get('tote', {}).get('exit', '‚Äî')}",
        ]
        save_state(uid, INTENT_DONE, STEP_FREE_CHAT, data)
        bot.send_message(uid, "\n".join(summary), reply_markup=MAIN_MENU)
        bot.send_message(uid, "–ì–æ—Ç–æ–≤ –≤—ã–Ω–µ—Å—Ç–∏ —ç—Ç–æ –≤ ¬´—Ñ–æ–∫—É—Å –Ω–µ–¥–µ–ª–∏¬ª –∏–ª–∏ –∏–¥—ë–º –¥–∞–ª—å—à–µ?", reply_markup=MAIN_MENU)
        return

    # fallback ‚Äî –≤–µ—Ä–Ω—ë–º—Å—è –≤ –∫–æ—É—á-—Å–ª–æ–π
    save_state(uid, INTENT_FREE, STEP_FREE_CHAT, data)
    bot.send_message(uid, "–û–∫–µ–π, –≤–µ—Ä–Ω—ë–º—Å—è –Ω–∞ —à–∞–≥ –Ω–∞–∑–∞–¥ –∏ —É—Ç–æ—á–Ω–∏–º –µ—â—ë —á—É—Ç—å-—á—É—Ç—å.", reply_markup=MAIN_MENU)

# ========= –ú–µ–Ω—é =========
MENU_BTNS = {
    "üöë –£ –º–µ–Ω—è –æ—à–∏–±–∫–∞": "error",
    "üß© –•–æ—á—É —Å—Ç—Ä–∞—Ç–µ–≥–∏—é": "strategy",
    "üìÑ –ü–∞—Å–ø–æ—Ä—Ç": "passport",
    "üóí –ü–∞–Ω–µ–ª—å –Ω–µ–¥–µ–ª–∏": "weekpanel",
    "üÜò –≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ": "panic",
    "ü§î –ù–µ –∑–Ω–∞—é, —Å —á–µ–≥–æ –Ω–∞—á–∞—Ç—å": "start_help",
}

@bot.message_handler(func=lambda m: m.text in MENU_BTNS)
def handle_menu(m: types.Message):
    uid = m.from_user.id
    st = load_state(uid)
    label = m.text
    code = MENU_BTNS[label]
    st["data"] = _append_history(st["data"], "user", label)

    if code == "error":
        if st["data"].get("problem_confirmed"):
            save_state(uid, INTENT_ERR, STEP_ERR_DESCR, st["data"])
            bot.send_message(uid, "–û–ø–∏—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫–µ–π—Å –æ—à–∏–±–∫–∏: –≥–¥–µ/–∫–æ–≥–¥–∞, –≤—Ö–æ–¥/—Å—Ç–æ–ø/–ø–ª–∞–Ω, –≥–¥–µ –æ—Ç—Å—Ç—É–ø–∏–ª, —á–µ–º –∑–∞–∫–æ–Ω—á–∏–ª–æ—Å—å.")
        else:
            save_state(uid, INTENT_FREE, STEP_FREE_CHAT, st["data"])
            bot.send_message(uid, "–ö–æ—Ä–æ—Ç–∫–æ ‚Äî —á—Ç–æ –∏–º–µ–Ω–Ω–æ —Å–µ–π—á–∞—Å –º–µ—à–∞–µ—Ç? –°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –≤ –æ–¥–Ω–æ–º-–¥–≤—É—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è—Ö.", reply_markup=MAIN_MENU)
    elif code == "start_help":
        bot.send_message(uid, "–ü–ª–∞–Ω: 1) –±—ã—Å—Ç—Ä—ã–π —Ä–∞–∑–±–æ—Ä –ø—Ä–æ–±–ª–µ–º—ã, 2) —Ñ–æ–∫—É—Å –Ω–µ–¥–µ–ª–∏, 3) —Å–∫–µ–ª–µ—Ç –¢–°. –° —á–µ–≥–æ –Ω–∞—á–Ω—ë–º?", reply_markup=MAIN_MENU)
        save_state(uid, data=st["data"])
    else:
        bot.send_message(uid, "–û–∫. –ï—Å–ª–∏ —Ö–æ—á–µ—à—å —É—Å–∫–æ—Ä–∏—Ç—å—Å—è ‚Äî –Ω–∞–∂–º–∏ ¬´üöë –£ –º–µ–Ω—è –æ—à–∏–±–∫–∞¬ª.", reply_markup=MAIN_MENU)
        save_state(uid, data=st["data"])

# ========= Callbacks =========
@bot.callback_query_handler(func=lambda c: True)
def on_cb(call: types.CallbackQuery):
    uid = call.from_user.id
    data = call.data or ""
    bot.answer_callback_query(call.id, "–û–∫")
    st = load_state(uid)

    if data == "confirm_problem":
        st["data"]["problem"] = st["data"].get("problem_draft", "‚Äî")
        st["data"]["problem_confirmed"] = True
        st["data"]["struct_offer_shown"] = False
        save_state(uid, INTENT_FREE, STEP_FREE_CHAT, st["data"])
        # –æ—Ç–¥–µ–ª—å–Ω—ã–º —Ö–æ–¥–æ–º ‚Äî –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        offer_structure(uid, st)
        return

    if data == "refine_problem":
        st["data"]["problem_confirmed"] = False
        save_state(uid, INTENT_FREE, STEP_FREE_CHAT, st["data"])
        bot.send_message(uid, "–•–æ—Ä–æ—à–æ. –°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π —Ç–æ–≥–¥–∞ –ø–æ–∫–æ–Ω–∫—Ä–µ—Ç–Ω–µ–µ, —á—Ç–æ –∏–º–µ–Ω–Ω–æ —Ä–∞–∑–±–∏—Ä–∞—Ç—å.", reply_markup=MAIN_MENU)
        return

    if data == "start_error_flow":
        st["data"]["problem_confirmed"] = True
        save_state(uid, INTENT_ERR, STEP_ERR_DESCR, st["data"])
        bot.send_message(uid, "–ù–∞—á–∏–Ω–∞–µ–º —Ä–∞–∑–±–æ—Ä. –û–ø–∏—à–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–ª—É—á–∞–π: –≤—Ö–æ–¥/–ø–ª–∞–Ω, –≥–¥–µ –æ—Ç—Å—Ç—É–ø–∏–ª, —Ä–µ–∑—É–ª—å—Ç–∞—Ç.")
        return

    if data == "skip_error_flow":
        bot.send_message(uid, "–û–∫–µ–π, –≤–µ—Ä–Ω—ë–º—Å—è –∫ —ç—Ç–æ–º—É –ø–æ–∑–∂–µ.", reply_markup=MAIN_MENU)
        return

    if data == "continue_session":
        st["data"]["awaiting_reply"] = False
        st["data"]["last_nag_at"] = _now_iso()
        save_state(uid, data=st["data"])
        bot.send_message(uid, "–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º. –ù–∞ —á—ë–º –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∏—Å—å?", reply_markup=MAIN_MENU)
        return

    if data == "restart_session":
        st = save_state(uid, INTENT_FREE, STEP_FREE_CHAT, {"history": [], "coach_turns": 0, "struct_offer_shown": False})
        bot.send_message(uid, "–û–∫–µ–π, –Ω–∞—á–Ω—ë–º –∑–∞–Ω–æ–≤–æ. –ß—Ç–æ —Å–µ–π—á–∞—Å —Ö–æ—á–µ—Ç—Å—è –ø–æ–ø—Ä–∞–≤–∏—Ç—å?", reply_markup=MAIN_MENU)
        return

# ========= HTTP =========
@app.get("/")
def root():
    return jsonify({"ok": True, "time": _now_iso(), "version": BOT_VERSION, "openai": openai_status})

@app.get("/version")
def version_api():
    return jsonify({"version": BOT_VERSION, "code_hash": _code_hash(), "status": "running", "timestamp": _now_iso(), "openai": openai_status})

@app.post(f"/{WEBHOOK_PATH}")
def webhook():
    if request.headers.get("X-Telegram-Bot-Api-Secret-Token") != TG_SECRET:
        abort(401)
    if request.content_length and request.content_length > MAX_BODY:
        abort(413, description="Body too large")
    body = request.get_data()
    if not body:
        abort(400, description="Empty body")
    try:
        update = telebot.types.Update.de_json(body.decode("utf-8"))
        if update is None:
            abort(400, description="Invalid update")
        bot.process_new_updates([update])
        return "OK", 200
    except Exception as e:
        log.error("Webhook processing error: %s", e)
        abort(500)

# ========= Housekeeping / Reminders =========
def cleanup_old_states(days: int = 30):
    try:
        days = int(days)
        db_exec(f"DELETE FROM user_state WHERE updated_at < NOW() - INTERVAL '{days} days'")
        log.info("Old user states cleanup done (> %s days).", days)
    except Exception as e:
        log.error("Cleanup error: %s", e)

def reminder_tick():
    if not REMINDERS_ENABLED:
        return
    try:
        mins = IDLE_MINUTES_REMIND
        reset_mins = IDLE_MINUTES_RESET
        rows = db_exec("SELECT user_id, intent, step, data, updated_at FROM user_state").mappings().all()
        now = datetime.now(timezone.utc)
        for r in rows:
            try:
                data = json.loads(r["data"] or "{}")
            except Exception:
                data = {}
            if not data.get("awaiting_reply"):
                continue
            last_user_ts = data.get("last_user_msg_at")
            if not last_user_ts:
                continue
            try:
                last_dt = datetime.fromisoformat(last_user_ts)
            except Exception:
                continue
            delta = now - last_dt
            nag_ok = True
            last_nag_at = data.get("last_nag_at")
            if last_nag_at:
                try:
                    if (now - datetime.fromisoformat(last_nag_at)) < timedelta(minutes=max(1, mins // 2)):
                        nag_ok = False
                except Exception:
                    pass
            if delta >= timedelta(minutes=reset_mins) and nag_ok:
                kb = types.InlineKeyboardMarkup().row(
                    types.InlineKeyboardButton("–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º", callback_data="continue_session"),
                    types.InlineKeyboardButton("–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ", callback_data="restart_session"),
                )
                bot.send_message(r["user_id"], "–î–µ–ª–∞ –∑–∞—Ç–∞—â–∏–ª–∏? –ì–æ—Ç–æ–≤ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–ª–∏ –Ω–∞—á–Ω—ë–º –∑–∞–Ω–æ–≤–æ?", reply_markup=kb)
                data["last_nag_at"] = _now_iso()
                save_state(r["user_id"], data=data)
            elif delta >= timedelta(minutes=mins) and nag_ok:
                kb = types.InlineKeyboardMarkup().row(
                    types.InlineKeyboardButton("–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º", callback_data="continue_session"),
                )
                bot.send_message(r["user_id"], "–ö–∞–∫ –±—É–¥–µ—à—å –≥–æ—Ç–æ–≤ ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∏–º?", reply_markup=kb)
                data["last_nag_at"] = _now_iso()
                save_state(r["user_id"], data=data)
    except Exception as e:
        log.error("Reminder error: %s", e)

def background_housekeeping():
    last_cleanup = time.time()
    while True:
        time.sleep(60)
        reminder_tick()
        if time.time() - last_cleanup > 24*60*60:
            cleanup_old_states(30)
            last_cleanup = time.time()

# ========= Init on import =========
try:
    init_db()
    log.info("DB initialized (import)")
except Exception as e:
    log.error("DB init (import) failed: %s", e)

if SET_WEBHOOK_FLAG:
    try:
        bot.remove_webhook()
        time.sleep(1)
        bot.set_webhook(
            url=f"{PUBLIC_URL}/{WEBHOOK_PATH}",
            secret_token=TG_SECRET,
            allowed_updates=["message", "callback_query"]
        )
        log.info("Webhook set to %s/%s", PUBLIC_URL, WEBHOOK_PATH)
    except Exception as e:
        log.error("Webhook setup error: %s", e)

try:
    th = threading.Thread(target=background_housekeeping, daemon=True)
    th.start()
except Exception as e:
    log.error("housekeeping thread error: %s", e)

# ========= Gunicorn entry =========
if __name__ == "__main__":
    port = int(os.getenv("PORT", "10000"))
    app.run(host="0.0.0.0", port=port)
